// Generated by CoffeeScript 1.9.1
(function() {
  var compile, debug, each, fcache, getDependencies, lint, logger, mapCompilerChain, pipeline, sysPath, throwError, waterfall;

  each = require('async-each');

  waterfall = require('async-waterfall');

  debug = require('debug')('brunch:pipeline');

  fcache = require('fcache');

  sysPath = require('path');

  logger = require('loggy');

  throwError = (function(_this) {
    return function(type, stringOrError) {
      var error, string;
      string = stringOrError instanceof Error ? stringOrError.toString().replace(/^([^:]+:\s+)/, '') : stringOrError;
      error = new Error(string);
      error.code = type;
      return error;
    };
  })(this);

  lint = function(data, path, linters, callback) {
    if (linters.length === 0) {
      return callback(null);
    } else {
      return each(linters, function(linter, callback) {
        return linter.lint(data, path, callback);
      }, callback);
    }
  };

  getDependencies = function(data, path, compilerDeps, compiler, callback) {
    var name;
    if (compiler.getDependencies) {
      name = compiler.constructor.name;
      if (compilerDeps) {
        return callback("Compiler '" + name + "' already passes dependencies. Remove `getDependencies` method.");
      }
      debug("getDependencies '" + path + "' with '" + name + "'");
      return compiler.getDependencies(data, path, callback);
    } else {
      return callback(null, compilerDeps || []);
    }
  };

  mapCompilerChain = function(compiler) {
    return function(params, next) {
      var callback, compiled, compilerArgs, compilerData, dependencies, path, source, sourceMap;
      if (!params) {
        return next();
      }
      dependencies = params.dependencies, compiled = params.compiled, source = params.source, sourceMap = params.sourceMap, path = params.path, callback = params.callback;
      debug("Compiling '" + path + "' with '" + compiler.constructor.name + "'");
      compilerData = compiled || source;
      compilerArgs = compiler.compile.length === 2 ? [
        {
          data: compilerData,
          path: path,
          map: sourceMap
        }
      ] : [compilerData, path];
      compilerArgs.push(function(error, result) {
        var compilerDeps;
        if (error != null) {
          return callback(throwError('Compiling', error));
        }
        if (result == null) {
          return next();
        }
        if (toString.call(result) === '[object Object]') {
          compiled = result.data;
          sourceMap = result.map;
          compilerDeps = result.dependencies;
        } else {
          compiled = result;
        }
        if (compiled == null) {
          throw new Error("Brunch SourceFile: file " + path + " data is invalid");
        }
        return getDependencies(source, path, compilerDeps, compiler, (function(_this) {
          return function(error, dependencies) {
            if (error != null) {
              return callback(throwError('Dependency parsing', error));
            }
            return next(null, {
              dependencies: dependencies,
              compiled: compiled,
              source: source,
              sourceMap: sourceMap,
              path: path,
              callback: callback
            });
          };
        })(this));
      });
      return compiler.compile.apply(compiler, compilerArgs);
    };
  };

  compile = function(source, path, compilers, callback) {
    var first;
    first = function(next) {
      return next(null, {
        source: source,
        path: path,
        callback: callback
      });
    };
    return waterfall([first].concat(compilers.map(mapCompilerChain)), callback);
  };

  pipeline = function(path, linters, compilers, callback) {
    return fcache.readFile(path, (function(_this) {
      return function(error, source) {
        debug("Linting '" + path + "'");
        return lint(source, path, linters, function(error) {
          if (error != null ? error.toString().match(/^warn\:\s/i) : void 0) {
            logger.warn("Linting of " + path + ": " + error);
          } else {
            if (error != null) {
              return callback(throwError('Linting', error));
            }
          }
          return compile(source, path, compilers, callback);
        });
      };
    })(this));
  };

  exports.pipeline = pipeline;

}).call(this);
